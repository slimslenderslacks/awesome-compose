{"cells":[{"kind":1,"language":"markdown","value":"## Compose sample application\n\n### Use with Docker Development Environments\n\nYou can open this sample in the Dev Environments feature of Docker Desktop version 4.12 or later.\n\n[Open in Docker Dev Environments ](https://open.docker.com/dashboard/dev-envs?url=https://github.com/docker/awesome-compose/tree/master/react-express-mongodb)\n\n### React application with a NodeJS backend and a MongoDB database\n\nProject structure:\n\n```\n.\n├── backend\n│   ├── Dockerfile\n│   ...\n├── compose.yaml\n├── frontend\n│   ├── ...\n│   └── Dockerfile\n└── README.md\n\n```\n\n\n\n[*compose.yaml*](compose.yaml)"},{"kind":2,"language":"dockercompose","value":""},{"kind":1,"language":"markdown","value":"The compose file defines an application with three services `frontend`, `backend` and `db`.\nWhen deploying the application, docker compose maps port 3000 of the frontend service container to port 3000 of the host as specified in the file.\nMake sure port 3000 on the host is not already being in use.\n\n## Deploy with docker compose"},{"kind":2,"language":"shellscript","value":"docker compose up -d"},{"kind":1,"language":"markdown","value":"## Expected result\n\nListing containers must show containers running and the port mapping as below:"},{"kind":2,"language":"shellscript","value":"docker ps"},{"kind":1,"language":"markdown","value":"After the application starts, navigate to `http://localhost:3000` in your web browser.\n\n<img src=\"./output.png\" width=\"500\"/>\n\nStop and remove the containers"},{"kind":2,"language":"shellscript","value":"docker compose down"},{"kind":1,"language":"markdown","value":"##### Explanation of `docker-compose`\n\n**Version**\n\nThe first line defines the version of a file. It sounds confusing :confused:. What is meant by version of file ??\n\n:pill: The Compose file is a YAML file defining services, networks, and volumes for a Docker application. So it is only a version of describing compose.yaml file. There are several versions of the Compose file format – 1, 2, 2.x, and 3.x.\n\n**Services**\n\nOur main goal to create a containers, it starts from here. As you can see there are three services(Docker images):\n\n* First is **frontend**\n* Second is **server** which is **backend - Express(NodeJS)**. I used a name server here, it's totally on you to name it **backend**.\n* Third is **mongo** which is db **MongoDB**.\n\n\n##### Service app (backend - NodeJS)\n\nWe make image of app from our `Dockerfile`, explanation below.\n\n**Explanation of service server**\n\n* Defining a **nodejs** service as **server**.\n* We named our **node server** container service as **server**. Assigning a name to the containers makes it easier to read when there are lot of containers on a machine, it can also avoid randomly generated container names. (Although in this case, **container_name** is also **server**, this is merely personal preference, the name of the service and container do not have to be the same.)\n* Docker container starts automatically if its fails.\n* Building the **server** image using the Dockerfile from the current directory and passing an argument to the\nbackend(server) `DockerFile`.\n* Mapping the host port to the container port.\n\n\n##### Service mongo\n\nWe add another service called **mongo** but this time instead of building it from `DockerFile` we write all the instruction here directly. We simply pull down the standard **mongo image** from the [DockerHub](https://hub.docker.com/) registry as we have done it for Node image.\n\n**Explanation of service mongo**\n\n* Defining a **mongodb** service as **mongo**.\n* Pulling the mongo 4.2.0 image image again from [DockerHub](https://hub.docker.com/).\n* Mount our current db directory to container.\n* For persistent storage, we mount the host directory ( just like I did it in **Node** image inside `DockerFile` to reflect the changes) `/data` ( you need to create a directory in root of your project in order to save changes to locally as well) to the container directory `/data/db`, which was identified as a potential mount point in the `mongo Dockerfile` we saw earlier.\n* Mounting volumes gives us persistent storage so when starting a new container, Docker Compose will use the volume of any previous containers and copy it to the new container, ensuring that no data is lost.\n* Finally, we link/depends_on the app container to the mongo container so that the mongo service is reachable from the app service.\n* In last mapping the host port to the container port.\n\n\n:key: `If you wish to check your DB changes on your local machine as well. You should have installed MongoDB locally, otherwise you can't access your mongodb service of container from host machine.`\n\n:white_check_mark: You should check your **mongo** version is same as used in image. You can see the version of **mongo** image in `docker-compose `file, I used **image: mongo:4.2.0**. If your mongo db version on your machine is not same then furst you have to updated your  local **mongo** version in order to works correctly."}]}