{"cells":[{"kind":1,"language":"markdown","value":"# Compose sample application\n\n<img src=\"../icon_wasm.svg\" width=\"500\"/>\n\nThis sample demonstrates a web application with a WebAssembly (Wasm) microservice, written in Rust. The Wasm microservice is an HTTP API connected to a MySQL (MariaDB) database. The API is invoked via from JavaScript in a web interface serving static HTML. The microservice is compiled into WebAssembly (Wasm) and runs in the WasmEdge Runtime, a secure and lightweight alternative to natively compiled Rust apps in Linux containers. Checkout [this article](https://blog.logrocket.com/rust-microservices-server-side-webassembly/) or [this video](https://www.youtube.com/watch?v=VSqMPFr7SEs) to learn how the Rust code in this microservice works.\n\n## Use with Docker Development Environments\n\nYou will need a version of Docker Desktop or Docker CLI with Wasm support.\n\n* [Install Docker Desktop + Wasm (Beta)](https://docs.docker.com/desktop/wasm/)\n* [Install Docker CLI + Wasm](https://github.com/chris-crone/wasm-day-na-22/tree/main/server)\n\n\n## WasmEdge server with Nginx proxy and MySQL database\n\nProject structure:\n\n```\n.\n+-- compose.yml\n|-- backend\n    +-- Dockerfile\n    |-- Cargo.toml\n    |-- src\n        +-- main.rs\n|-- frontend\n    +-- index.html\n    |-- js\n        +-- app.js\n|-- db\n    +-- orders.json\n    |-- update_order.json\n\n```\n\n\n\nThe [compose.yml](compose.yml) file:"},{"kind":2,"language":"shellscript","value":""},{"kind":1,"language":"markdown","value":"The compose file defines an application with three services `frontend`, `backend` and `db`. The `frontend` is a simple Nginx server that hosts static web pages that access the `backend` web service, in the WasmEdge container, via HTTP port 8080. When deploying the application, docker compose maps port 8090 of the `frontend` service container to port 8090 of the host as specified in the file. Make sure that ports 8090 and 8080 on the host are not already being used.\n\n## Deploy with docker compose"},{"kind":2,"language":"shellscript","value":"docker compose up -d"},{"kind":1,"language":"markdown","value":"## Expected result"},{"kind":2,"language":"shellscript","value":"docker compose ps"},{"kind":1,"language":"markdown","value":"After the application starts, go to `http://localhost:8090` in your web browser to display the web frontend.\n\n### Using the API with `curl`\n\nAs an alternative to the web frontend, you can use `curl` to interact with the WasmEdge API directly (the `backend` service).\n\nWhen the WasmEdge web service receives a GET request to the `/init` endpoint, it would initialize the database with the `orders` table."},{"kind":2,"language":"shellscript","value":""},{"kind":1,"language":"markdown","value":"When the WasmEdge web service receives a POST request to the `/create_order` endpoint, it extracts the JSON data from the POST body and inserts an `Order` record into the database table.\nTo insert multiple records, use the `/create_orders` endpoint and POST a JSON array of `Order` objects:"},{"kind":2,"language":"shellscript","value":""},{"kind":1,"language":"markdown","value":"When the WasmEdge web service receives a GET request to the `/orders` endpoint, it gets all rows from the `orders` table and return the result set in a JSON array in the HTTP response."},{"kind":2,"language":"shellscript","value":""},{"kind":1,"language":"markdown","value":"When the WasmEdge web service receives a POST request to the `/update_order` endpoint, it extracts the JSON data from the POST body and update the `Order` record in the database table that matches the `order_id` in the input data."},{"kind":2,"language":"shellscript","value":""},{"kind":1,"language":"markdown","value":"When the WasmEdge web service receives a GET request to the `/delete_order` endpoint, it deletes the row in the `orders` table that matches the `id` GET parameter."},{"kind":2,"language":"shellscript","value":""}]}